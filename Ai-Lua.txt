// Global Project-GLD lua exports
// sol::this_state arguments into function call are ignored into lua for exmaple: 	client[("add_callback")] = ns_client::add_callback; void add_callback(sol::this_state s, std::string eventname, sol::protected_function func) becomes: cliend.add_callback("on_gamesearch") in lua
// arguments that has = on it for example:  int delay = 0 are optional
// sol::nil are functions that doesnt exists into gld
lua = sol::state(sol::c_call<decltype(&lua_panic), &lua_panic>);	

lua.open_libraries(sol::lib::base, sol::lib::string, sol::lib::math, sol::lib::table, sol::lib::debug, sol::lib::package, sol::lib::os, sol::lib::coroutine, sol::lib::io, sol::lib::utf8, sol::lib::bit32); // All useful lua libraries
lua.new_usertype<JsonWrapper>("JsonWrapper",
	"parse", &JsonWrapper::parse
	); // 	static sol::object parse(const std::string& jsonString)
lua.new_usertype<HtmlWrapper>("HtmlWrapper", // this html wrapper is deprecated, use html.parse() instead (kept only for backwards comaptibili8ty with older scripts [gumbo html])
	"findAttribute", &HtmlWrapper::findAttribute
); // static sol::table findAttribute(const std::string& htmlString,	const std::string& elementTagName,		const std::string& elementTermKey,		const std::string& elementTermValue,		const std::string& desiredResultKey)

/*html and xml parser new version (lexor and libxml2)*/
// HtmlDocument usertype
lua.new_usertype<HtmlDocument>("HtmlDocument",
	"css", &HtmlDocument::css,           // sol::table css(sol::this_state s, const std::string& selector)
	"root", &HtmlDocument::root,         // HtmlNode root()
	"body", &HtmlDocument::body          // HtmlNode body()
);

// HtmlNode usertype
lua.new_usertype<HtmlNode>("HtmlNode",
	"tag", &HtmlNode::tag,               // std::string tag() const
	"text", &HtmlNode::text,             // std::string text() const
	"attr", &HtmlNode::attr,             // sol::optional<std::string> attr(const std::string& name) const
	"parent", &HtmlNode::parent,         // HtmlNode parent() const
	"children", &HtmlNode::children      // sol::table children(sol::this_state s) const
);

// HTML parser
lua["html"] = lua.create_table_with(
	"parse", [](const std::string& html) {  // HtmlDocument parse(const std::string& html) - parse HTML string and return document
		HtmlDocument d;
		d.doc = lxb_html_document_create();
		lxb_html_document_parse(
			d.doc,
			(const lxb_char_t*)html.c_str(),
			html.size()
		);
		return d;
	}
);

// XmlDocument usertype
lua.new_usertype<XmlDocument>("XmlDocument",
	"xpath", &XmlDocument::xpath,        // sol::table xpath(sol::this_state s, const std::string& expr)
	"root", &XmlDocument::root           // XmlNode root()
);

// XmlNode usertype
lua.new_usertype<XmlNode>("XmlNode",
	"name", &XmlNode::name,              // std::string name() const
	"text", &XmlNode::text,              // std::string text() const
	"attr", &XmlNode::attr               // sol::optional<std::string> attr(const std::string& name) const
);

// XML parser
lua["xml"] = lua.create_table_with(
	"parse", [](const std::string& xml) {   // XmlDocument parse(const std::string& xml) - parse XML string and return document
		XmlDocument d;
		d.doc = xmlReadMemory(
			xml.c_str(),
			(int)xml.size(),
			"input.xml",
			nullptr,
			XML_PARSE_RECOVER
		);
		return d;
	}
);
lua[("print")] = ns_client::Print; // void Print(sol::this_state ts, sol::variadic_args args) // this prints to cosnole, we onyl want to print and attach console when debugging
lua[("exec")] = ns_file::exec; // 	void exec(sol::this_state s, std::string& execpath, int delay = 0, std::string commandline = "", bool isinnosetup = false, std::string innoproccess = "")
lua["system"] = ns_file::system_exec; // void system_exec(sol::this_state s, const std::string& command, int delay = 0) execute system commands (CMD Commands)
lua["system_output"] = ns_file::system_exec_output; // std::string system_exec_output(sol::this_state s, const std::string& command, int delay = 0) execute system commands (CMD Commands) and get output
lua[("sleep")] = luasleep; // void luasleep(int ms)
lua[("beep")] = luaBeep; // void beep(int frequency = 1000, int duration = 500)
lua[("xor_decrypt")] = xor_decrypt; //	std::string xor_decrypt(const std::string& hex)
lua[("xor_encrypt")] = xor_encrypt; //	std::string xor_encrypt(const std::string& plain)
lua[("__nil_callback")] = []() {}; // nil callback function placeholder

lua.new_usertype <GameInfo>(("GameInfo"), sol::constructors <>(), // all inside this constructor are strings
	(std::string)"id", &GameInfo::id,
	(std::string)"name", &GameInfo::name,
	(std::string)"initoptions", &GameInfo::initoptions,
	(std::string)"imagePath", &GameInfo::imagePath,
	(std::string)"exePath", &GameInfo::exePath
	);

//this is the main gld cef brwoser, you can get this by browser.get_main(). 
//available callbacks are: on_browserloaded (use this to get page contents after tis loaded), on_browserbeforedownload (trigegred when an download is addded torugh brwoser, do not sue it tor esolve urls!), on_browserbeforeresourceload, on_browserconsolemessage, on_captchadetected, on_captchasolved
lua.new_usertype<GLDBrowser>("GLDBrowser",
	sol::constructors<GLDBrowser()>(),

	"burl", & GLDBrowser::burl, // std::string burl
	"name", & GLDBrowser::name, // std::string name
	"is_rendering", & GLDBrowser::is_rendering, // bool is_rendering

	"HasBrowser", & GLDBrowser::HasBrowser, // bool HasBrowser()
	"CanGoBack", & GLDBrowser::CanGoBack, // bool CanGoBack()
	"CanGoForward", & GLDBrowser::CanGoForward, // bool CanGoForward()
	"IsLoading", & GLDBrowser::IsLoading, // bool IsLoading()
	"GetID", & GLDBrowser::GetID, // int GetID()
	"HasBrowserAndFocusedFrame", & GLDBrowser::HasBrowserAndFocusedFrame, // bool HasBrowserAndFocusedFrame()
	"HasBrowserAndMainFrame", & GLDBrowser::HasBrowserAndMainFrame, // bool HasBrowserAndMainFrame()
	"HasBrowserAndHost", & GLDBrowser::HasBrowserAndHost, // bool HasBrowserAndHost()

	"ChangeBrowserURL", & GLDBrowser::ChangeBrowserURL, // void ChangeBrowserURL(const char* URL)
	"ReloadBrowserPage", & GLDBrowser::ReloadBrowserPage, // void ReloadBrowserPage()
	"ReloadIgnoreCache", & GLDBrowser::ReloadIgnoreCache, // void ReloadIgnoreCache()
	"GoBackBrowser", & GLDBrowser::GoBackBrowser, // void GoBackBrowser()
	"GoForwardBrowser", & GLDBrowser::GoForwardBrowser, // void GoForwardBrowser()
	"CancelLoading", & GLDBrowser::CancelLoading, // void CancelLoading()
	"CloseBrowser", & GLDBrowser::CloseBrowser, // bool CloseBrowser()
	"BrowserUrl", & GLDBrowser::BrowserUrl, // std::string BrowserUrl()

	"GetPageTitle", & GLDBrowser::GetPageTitle, // std::string GetPageTitle()
	"GetBrowserSource", & GLDBrowser::GetBrowserSource, //     void GetBrowserSource(sol::protected_function callback)

	"ExecuteJavaScriptOnMainFrame", & GLDBrowser::ExecuteJavaScriptOnMainFrame, // void ExecuteJavaScriptOnMainFrame(const std::string& javascript_code)
	"ExecuteJavaScriptOnFocusedFrame", & GLDBrowser::ExecuteJavaScriptOnFocusedFrame, // void ExecuteJavaScriptOnFocusedFrame(const std::string& javascript_code)

	"Copy", & GLDBrowser::Copy, // void Copy()
	"Cut", & GLDBrowser::Cut, // void Cut()
	"Paste", & GLDBrowser::Paste, // void Paste()
	"PasteAsPlainText", & GLDBrowser::PasteAsPlainText, // void PasteAsPlainText()
	"Undo", & GLDBrowser::Undo, // void Undo()
	"Redo", & GLDBrowser::Redo, // void Redo()
	"SelectAll", & GLDBrowser::SelectAll, // void SelectAll()

	"ZoomIn", & GLDBrowser::ZoomIn, // void ZoomIn()
	"ZoomOut", & GLDBrowser::ZoomOut, // void ZoomOut()
	"ZoomReset", & GLDBrowser::ZoomReset, // void ZoomReset()

	"MuteAudio", & GLDBrowser::MuteAudio, // void MuteAudio(bool mute)
	"Print", & GLDBrowser::Print, // void Print()
	"Resize", & GLDBrowser::Resize, // void Resize()
	"ViewSource", & GLDBrowser::ViewSource, // void ViewSource()
	"SavePageAs", & GLDBrowser::SavePageAs, // void SavePageAs()

	"Find", & GLDBrowser::Find, // void Find(const std::string& searchText, bool forward, bool matchCase, bool findNext)
	"StopFinding", & GLDBrowser::StopFinding, // void StopFinding(bool clearSelection)

	"AddDownload", & GLDBrowser::AddDownload, // void AddDownload(const std::string& url)
	"DownloadImage", & GLDBrowser::DownloadImage, // void DownloadImage(const std::string& imageUrl)

	"ShowDevTools", & GLDBrowser::ShowDevTools, // void ShowDevTools()
	"CloseDevTools", & GLDBrowser::CloseDevTools, // void CloseDevTools()
	"InspectElementAt", & GLDBrowser::InspectElementAt, // void InspectElementAt(int x, int y)

	"OpenBrowserPopup", & GLDBrowser::OpenBrowserPopup, // void OpenBrowserPopup(const std::string& url, const std::string& title)

	"ClearLocalStorage", & GLDBrowser::ClearLocalStorage, // void ClearLocalStorage()
	"SetCustomLocalStorageValueForURL", & GLDBrowser::SetCustomLocalStorageValueForURL, // void SetCustomLocalStorageValueForURL(const std::string& url, const std::string& key, const std::string& value)
	"RemoveCustomLocalStorageValueForURL", & GLDBrowser::RemoveCustomLocalStorageValueForURL // void RemoveCustomLocalStorageValueForURL(const std::string& url, const std::string& key)
);

auto client = lua.create_table();
client[("add_callback")] = ns_client::add_callback; // 	void add_callback(sol::this_state s, std::string eventname, sol::protected_function func)
client[("load_script")] = ns_client::load_script; // 	void load_script(std::string name)
client[("unload_script")] = ns_client::unload_script; // void unload_script(std::string name)
client[("create_script")] = ns_client::create_script; // void create_script(std::string name, std::string data)
client[("auto_script_update")] = ns_client::auto_script_update; // void auto_script_update(std::string scripturl, std::string scriptversion) expects local VERSION = "" into the scriptversion (defined in lua as local VERSION = "")
client[("log")] = ns_client::log; // 	void log(std::string title, std::string text)
client[("quit")] = ns_client::quit; // 	void quit(sol::this_state s)
client[("GetVersion")] = ns_client::GetVersion; // 	std::string GetVersion(sol::this_state s)
client[("GetVersionFloat")] = ns_client::GetVersionFloat; // 	float GetVersionFloat(sol::this_state s)
client[("GetVersionDouble")] = ns_client::GetVersionDouble; // 	double GetVersionDouble(sol::this_state s)
client[("CleanSearchTextureCache")] = ns_client::CleanSearchTextureCache; //	void CleanSearchTextureCache(sol::this_state s)
client[("CleanLibraryTextureCache")] = ns_client::CleanLibraryTextureCache; // 	void CleanLibraryTextureCache(sol::this_state s)
client[("GetScriptsPath")] = ns_client::GetScriptsPath; // 	std::string GetScriptsPath(sol::this_state s)
client[("GetDefaultSavePath")] = ns_client::GetDefaultSavePath; // 	std::string GetDefaultSavePath(sol::this_state s)
client[("GetScreenHeight")] = ns_client::GetScreenHeight; // 	int GetScreenHeight()
client[("GetScreenWidth")] = ns_client::GetScreenWidth; // 	int GetScreenWidth()

auto notifications = lua.create_table();
notifications[("push")] = ns_notifications::push; // 	void push(std::string title, std::string text)
notifications[("push_success")] = ns_notifications::push_success; // 	void push_success(std::string title, std::string text)
notifications[("push_error")] = ns_notifications::push_error; // 	void push_error(std::string title, std::string text)
notifications[("push_warning")] = ns_notifications::push_warning; // 	void push_warning(std::string title, std::string text)

auto menu = lua.create_table();
menu[("set_dpi")] = ns_menu::set_dpi; // 	void set_dpi(double dpi)
menu[("set_visible")] = ns_menu::set_visible; // 	void set_visible(bool visible)
menu[("is_main_window_active")] = ns_menu::is_main_window_active; // 	bool is_main_window_active()
menu[("next_line")] = ns_menu::next_line; //	void next_line(sol::this_state s)
menu[("add_check_box")] = ns_menu::add_check_box; // 	void add_check_box(sol::this_state s, const std::string& name)
menu[("add_button")] = ns_menu::add_button; // 	void add_button(sol::this_state s, const std::string& name)
menu[("add_text")] = ns_menu::add_text; // 	void add_text(sol::this_state s, const std::string& text)
menu[("add_input_text")] = ns_menu::add_input_text; //	void add_input_text(sol::this_state s, const std::string& name)
menu[("add_input_int")] = ns_menu::add_input_int; // 	void add_slider_int(sol::this_state s, const std::string& name, int min, int max)
menu[("add_input_float")] = ns_menu::add_input_float; // 	void add_slider_float(sol::this_state s, const std::string& name, float min, float max)
menu[("add_combo_box")] = ns_menu::add_combo_box; // 	void add_combo_box(sol::this_state s, std::string name, std::vector <std::string> labels) //-V813
menu[("add_slider_int")] = ns_menu::add_slider_int; // 	void add_input_int(sol::this_state s, const std::string& name)
menu[("add_slider_float")] = ns_menu::add_slider_float; // 	void add_input_float(sol::this_state s, const std::string& name)
menu[("add_color_picker")] = ns_menu::add_color_picker; // 	void add_color_picker(sol::this_state s, const std::string& name)
menu[("add_keybind")] = ns_menu::add_keybind; // 	void add_keybind(sol::this_state s, const std::string& name, int default_key)
menu[("get_bool")] = ns_menu::get_bool; // 	bool get_bool(std::string name)
menu[("get_text")] = ns_menu::get_text; // 	std::string get_text(std::string name)
menu[("get_int")] = ns_menu::get_int; // 	int get_int(std::string name)
menu[("get_float")] = ns_menu::get_float; // 	float get_float(std::string name)
menu[("get_color")] = ns_menu::get_color; // 	Color get_color(std::string name)
menu[("get_keybind")] = ns_menu::get_keybind; //    int get_keybind(std::string name)
menu[("set_bool")] = ns_menu::set_bool; // 	void set_bool(std::string name, bool value)
menu[("set_text")] = ns_menu::set_text; // 	void set_text(std::string name, std::string value)
menu[("set_int")] = ns_menu::set_int; // 	void set_int(std::string name, int value)
menu[("set_float")] = ns_menu::set_float; // 	void set_float(std::string name, float value)
menu[("set_color")] = ns_menu::set_color; // 	void set_color(std::string name, Color value)
menu[("set_keybind")] = ns_menu::set_keybind; // 	void set_keybind(std::string name, int value)
// all added menu variables uses the get_ and the set_ specific for it to get the current status or to set it, buttons use the client callback - `on_button_(button name)` only run the function when one button (added by a lua script) is pressed, put the button name without ()! and make sure that you added the button before!!![you must add the client callback to then listen to button getting pressed{client.add_callback}]

auto utils = lua.create_table();
utils[("AttachConsole")] = Utils::AttachConsole;//	void AttachConsole()
utils[("DetachConsole")] = Utils::DetachConsole;//	void DetachConsole()
utils[("ConsolePrint")] = Utils::ConsolePrint;//	bool ConsolePrint(bool logToFile, const char* fmt, ...) {
utils[("GetTimeString")] = Utils::GetTimeString;//	std::string GetTimeString()
utils[("GetTimestamp")] = Utils::GetTimestamp;//	std::string GetTimestamp()
utils[("GetTimeUnix")] = ns_utils::GetTimeUnix;//	int GetTimeUnix()
utils[("Log")] = Utils::Log;//	void Log(const char* fmt, ...) // use gldconsole instead of this for betetr logging!
//log function logs to an file called Project-GLD.log at the same folder as gld exe, ConsolePrint needs to be called after attach console!

auto http = lua.create_table();
http["get"] = ns_http::get;          // std::string get(sol::this_state s, const std::string& link, const sol::table& headers)
http["post"] = ns_http::post;        // std::string post(sol::this_state s, const std::string& link, const std::string& body, const sol::table& headers)
http["put"] = ns_http::put;          // std::string put(sol::this_state s, const std::string& link, const std::string& body, const sol::table& headers)
http["patch"] = ns_http::patch;      // std::string patch(sol::this_state s, const std::string& link, const std::string& body, const sol::table& headers)
http["delete"] = ns_http::del;       // std::string del(sol::this_state s, const std::string& link, const sol::table& headers)
http["head"] = ns_http::head;        // std::string head(sol::this_state s, const std::string& link, const sol::table& headers)
http["options"] = ns_http::options;  // std::string options(sol::this_state s, const std::string& link, const sol::table& headers)
http["request"] = ns_http::request;  // std::string request(sol::this_state s, const std::string& method, const std::string& link, const std::string& body, const sol::table& headers)
http[("CloudFlareSolver")] = ImGui::CloudFlareSolver; // void ImGui::CloudFlareSolver(const std::string& url)
http[("byetresolver")] = ns_http::byetresolver; // 	std::string byetresolver(sol::this_state s, const std::string& url)
//function CloudFlareSolver returns an callback at client callbacks : - `on_cfdone` execute the function when the cloudflare solver resolved the link and returns the cloudflare cookie and url of the request (you need to use the following user agent alongside with the cookie to work: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36 ProjectGLD/2.15) [soo make sure to do the cliend.add_callback if you want to listen to when cloudflare resolver is done

auto file = lua.create_table();
file[("append")] = ns_file::append; // void append(sol::this_state s, std::string& path, std::string& data)
file[("write")] = ns_file::write;//	void write(sol::this_state s, std::string& path, std::string& data)
file[("read")] = ns_file::read;// std::string read(sol::this_state s, std::string& path)
file[("delete")] = ns_file::erase;// void erase(sol::this_state s, std::string& path)
file[("exists")] = ns_file::exists;// bool exists(sol::this_state s, std::string& path)
file[("exec")] = ns_file::exec;// void exec(sol::this_state s, std::string& execpath, int delay = 0, std::string commandline = "", bool isinnosetup = false, std::string innoproccess = "")
file[("listfolders")] = ns_file::listfolders;//	std::vector<std::string> listfolders(std::string path)
file[("listexecutables")] = ns_file::listexecutables;//	std::vector<std::string> listexecutables(std::string path)
file[("listexecutablesrecursive")] = ns_file::listexecutablesrecursive;// std::vector<std::string> listexecutablesrecursive(std::string path)
file[("listcompactedfiles")] = ns_file::listcompactedfiles;// std::vector<std::string> listcompactedfiles(std::string path) zip,rar,7z,tar, etc.
file[("getusername")] = ns_file::GetWindowsUserName(); // std::string GetWindowsUserName()
file["create_directory"] = ns_file::create_directory;   // void create_directory(std::string& path)
file["copy_file"] = ns_file::copy_file;                 // void copy_file(std::string& src, std::string& dst)
file["move_file"] = ns_file::move_file;                 // void move_file(std::string& src, std::string& dst)
file["get_filename"] = ns_file::get_filename;           // std::string get_filename(std::string& path)
file["get_extension"] = ns_file::get_extension;         // std::string get_extension(std::string& path)
file["get_parent_path"] = ns_file::get_parent_path;     // std::string get_parent_path(std::string& path)
file["list_directory"] = ns_file::list_directory;       // sol::table list_directory(std::string& path)

auto game = lua.create_table();
game["getgamename"] = ns_game::getgamename; // 	std::string getgamename(sol::this_state s) gets the game name from serach  [into game page]

auto dll = lua.create_table();
dll["inject"] = ns_dll::inject; // 	bool inject(sol::this_state s, std::string processexename, std::string dllpath, int delay) // processexename ex: GoW.exe | delay ex: 300 (means 300 milliseconds)
dll["injectx86"] = ns_dll::injectx86; // 	bool injectx86(sol::this_state s, std::string processexename, std::string dllpath, int delay) // processexename ex: GoW.exe | delay ex: 300 (means 300 milliseconds)
dll["innohook"] = ns_dll::innohook; // 	bool innohook(sol::this_state s, std::string processname)
// innohook fucntion calls an callback at on_setupcompleted soo make sure to add this callback using client.add_callback to listen to reuslts when its done

auto browser = lua.create_table();
browser["CreateBrowser"] = ns_browser::CreateBrowser; //  GLDBrowser* CreateBrowser(const std::string& browser_name, const std::string& browser_url) // browsers name are unique, youre able toc reate only one browser with same name, aknowledge it when doing download resolvers (since download managers support multiple downloads at same time from same provider)
browser["GetBrowserByName"] = ns_browser::GetBrowserByName; // GLDBrowser* GetBrowserByName(const std::string& std::string name)
browser["GetBrowserByID"] = ns_browser::GetBrowserByID; // GLDBrowser* GetBrowserByID(int id)
browser["set_visible"] = ns_browser::set_visible; // void set_visible(bool visible, const std::string& browser_name) // set the lua browser visibility, making it visible (or invisible) to user
browser["IsBrowserVisible"] = ns_browser::IsBrowserVisible; // bool IsBrowserVisible(const std::string& browser_name) // returns true if browser is visible to user and false when its invisible
browser["EnableCaptchaDetection"] = ns_browser::EnableCaptchaDetection; // void EnableCaptchaDetection(const std::string& browser_name) // set captcha detection on (default is on, unless some script disable)
browser["DisableCaptchaDetection"] = ns_browser::DisableCaptchaDetection; // void DisableCaptchaDetection(const std::string& browser_name) //  set captcha detection off (you may disable if you get stuck at cloudflare just a moment page)
browser["IsCaptchaDetectionOn"] = ns_browser::IsCaptchaDetectionOn; // bool IsBrowserVisible(const std::string& browser_name) // returns true if captcha detection is on and false when its not

auto communication = lua.create_table();
communication["receiveSearchResults"] = ns_communication::receiveSearchResults; // 	void receiveSearchResults(const sol::table& resultsTable)
communication["RefreshScriptResults"] = Menu::RefreshScriptResults; //     void RefreshScriptResults()

auto steamapi = lua.create_table();
steamapi["GetAppID"] = SteamApi::GetAppID; // std::string SteamApi::GetAppID(const std::string& name)
steamapi["GetSystemRequirements"] = SteamApi::GetSystemRequirementsString; // std::string SteamApi::GetSystemRequirementsString(const std::string& appid)
steamapi["GetGameData"] = SteamApi::GetGameDataString; // std::string SteamApi::GetGameDataString(const std::string& appid)
steamapi["OpenSteam"] = SteamApi::OpenSteam; // void SteamApi::OpenSteam()
steamapi["IsSteamRunning"] = SteamApi::IsSteamRunning; // bool SteamApi::IsSteamRunning()

auto download = lua.create_table();
download["DownloadFile"] = ns_download::DownloadFile; // 	void DownloadFile(sol::this_state s, std::string downloadurl)
download["GetFileNameFromUrl"] = ns_download::GetFileNameFromUrl; // 	std::string GetFileNameFromUrl(sol::this_state s, std::string url)
download["DirectDownload"] = ns_download::DirectDownload; // 	void DirectDownload(sol::this_state s, std::string downloadurl, std::string downloadpath)
download["DownloadImage"] = ns_download::DownloadImage; // 	std::string DownloadImage(sol::this_state s, std::string imageurl)
download["ChangeDownloadPath"] = ns_download::ChangeDownloadPath; // 	void ChangeDownloadPath(sol::this_state s, std::string path)
download["GetDownloadPath"] = ns_download::GetDownloadPath; // 	std::string GetDownloadPath(sol::this_state s)
download["ChangeMaxActiveDownloads"] = ns_download::ChangeMaxActiveDownloads; // 	void MaxActiveDownloads(int maxdownloads)
download["GetMaxActiveDownloads"] = ns_download::GetMaxActiveDownloads; // int GetMaxActiveDownloads()
download["SetMaxConnections"] = ns_download::SetMaxConnections; // void SetMaxConnections(int maxconnections)
download["GetMaxConnections"] = ns_download::GetMaxConnections; // int GetMaxConnections()
download["TorrentContentToMagnet"] = TorrentToMagnet::TorrentContentToMagnet; // std::string TorrentContentToMagnet(std::string torrentcontent)
download["TorrentToMagnet"] = TorrentToMagnet::TorrentToMagnet; // std::string TorrentToMagnet(std::string filepath)
download["SetHistoryUrl"] = ns_download::SetHistoryUrl; // void SetHistoryUrl(std::string url, std::string ogurl) (keep in mind if you cancel an download then restart it torugh brwoser by changing url or anything else, ya must set it to the downlaod be able to resume if app is closed.)[og url is the base url, the unresolved one]

auto gamelibrary = lua.create_table();
gamelibrary["launch"] = ns_gamelibrary::Launchgame; // 	bool Launchgame(int id)
gamelibrary["close"] = ns_gamelibrary::CloseGame;
gamelibrary["addGame"] = ns_gamelibrary::addGame; // 	void addGame(sol::this_state s, std::string& exePath, std::string& imagePath, std::string& gamename, std::string& commandline, bool disableigdbid = false)
gamelibrary["changeGameinfo"] = ns_gamelibrary::changeGameinfo; // 	void changeGameinfo(sol::this_state s, int id, std::string exePath = "", std::string imagePath = "", std::string gamename = "", std::string commandline = "")
gamelibrary["removeGame"] = ns_gamelibrary::removeGame; // 	void removeGame(sol::this_state s, int id)
gamelibrary["GetGameIdFromName"] = ns_gamelibrary::GetGameIdFromName; // 	int GetGameIdFromName(std::string name)
gamelibrary["GetGameNameFromId"] = ns_gamelibrary::GetGameNameFromId; // 	std::string GetGameNameFromId(int id)
gamelibrary["GetGamePath"] = ns_gamelibrary::GetGamePath; // 	std::string GetGamePath(int id)
gamelibrary["GetGameList"] = ns_gamelibrary::GetGameList; // 	std::vector<sol::table> GetGameList(sol::this_state s)

auto settings = lua.create_table();
settings["save"] = ns_settings::save; // 	void save()
settings["load"] = ns_settings::load; // 	void load()

auto zip = lua.create_table();
zip["extract"] = Features::ExtractFile; //     void ExtractFile(std::string source, std::string destination, bool deleteaftercomplete, std::string pass)
// extract function call an client callback: - `on_extractioncompleted` execute the function when the extraction progress is completed and retrieve the path to where it got extracted and from wich file it got extracted
// make sure to call taht callback with client.add_callback to listen to itss results

auto gldconsole = lua.create_table();
gldconsole["print"] = ns_gldconsole::AddLog; // 	void AddLog(std::string fmt) (recommended way to do logs etc)
gldconsole["show"] = ns_gldconsole::ShowConsole; // 	void ShowConsole()
gldconsole["close"] = ns_gldconsole::CloseConsole; // 	void CloseConsole()

auto saves = lua.create_table();
saves["Backup"] = ns_save::Backup; // 	void Backup(const std::string& name) {
saves["Restore"] = ns_save::Restore; // 	void Restore(const std::string& name) {
saves["BackupAll"] = ns_save::BackupAll; // 	void BackupAll() {
saves["RestoreAll"] = ns_save::RestoreAll; // 	void RestoreAll() {
saves["Download"] = ns_save::Download; // 	void Download(const std::string& name) {
saves["Upload"] = ns_save::Upload; // 	void Upload(const std::string& name) {
saves["UploadAll"] = ns_save::UploadAll; // 	void UploadAll() {
saves["DownloadAll"] = ns_save::DownloadAll; // 	void DownloadAll() {
saves["RefreshBackup"] = ns_save::RefreshBackup; // 	void RefreshBackup() {
saves["RefreshRestore"] = ns_save::RefreshRestore; // 	void RefreshRestore() {
saves["RefreshCloud"] = ns_save::RefreshCLoud; // 	void RefreshCLoud() {
saves["RefreshAll"] = ns_save::RefreshAll; // 	void RefreshAll() {
saves["GetBackupGamesList"] = ns_save::GetBackupGamesList; // 	void RefreshAll() {
saves["GetRestoreGamesList"] = ns_save::GetRestoreGamesList; // 	std::string GetRestoreGamesList()
saves["GetCloudGamesList"] = ns_save::GetCloudGamesList; // 	std::vector<std::string> GetCloudGamesList()

auto input = lua.create_table();
input["is_key_down"] = ns_input::is_key_down;           // bool is_key_down(int vk_code)
input["is_key_pressed"] = ns_input::is_key_pressed;     // bool is_key_pressed(int vk_code)
input["get_key_state"] = ns_input::get_key_state;       // short get_key_state(int vk_code)
input["is_key_toggled"] = ns_input::is_key_toggled;     // bool is_key_toggled(int vk_code)
input["key_press"] = ns_input::key_press;               // void key_press(int vk_code, int delay = 0, int delay2 = 50) delay1 means before the key is pressed, delay2 means after the key is pressed before its released (on key up)
input["key_down"] = ns_input::key_down;                 // void key_down(int vk_code, int delay = 0)
input["key_up"] = ns_input::key_up;                     // void key_up(int vk_code, int delay = 0)
input["get_mouse_pos"] = ns_input::get_mouse_pos;       // sol::table get_mouse_pos(sol::this_state s)
input["set_mouse_pos"] = ns_input::set_mouse_pos;       // void set_mouse_pos(int x, int y)
input["mouse_click"] = ns_input::mouse_click;           // void mouse_click(int button = 0, int delay = 0, int delay2 = 50) delay1 means before the key is pressed, delay2 means after the key is pressed before its released (on key up)
input["mouse_down"] = ns_input::mouse_down;             // void mouse_down(int button = 0, int delay = 0)
input["mouse_up"] = ns_input::mouse_up;                 // void mouse_up(int button = 0, int delay = 0)
input["mouse_wheel"] = ns_input::mouse_wheel;           // void mouse_wheel(int delta, int delay = 0)

auto vk = lua.create_table();
register_virtual_keys(vk); // register all windows keyboard virtual keys into lua

auto base64 = lua.create_table();
base64["encode"] = ns_base64::encode; // 	std::string encode(std::string& in)
base64["decode"] = ns_base64::decode; // 	std::string decode(std::string& in)
base64["encode_shifted"] = ns_base64::encode_shifted; // 	std::string encode_shifted(std::string& in)
base64["decode_shifted"] = ns_base64::decode_shifted; // 	std::string decode_shifted(std::string& in)

// these are how you call each lua table in lua for example on lua: cliend.add_callback("on_gamesearch")
lua[("client")] = client;
lua[("menu")] = menu;
lua[("utils")] = utils;
lua[("http")] = http;
lua[("file")] = file;
lua[("game")] = game;
lua[("communication")] = communication;
lua[("SteamApi")] = steamapi;
lua[("Download")] = download; 
lua[("GameLibrary")] = gamelibrary; 
lua[("Notifications")] = notifications; 
lua[("settings")] = settings; 
lua[("zip")] = zip; 
lua[("dll")] = dll; 
lua[("gldconsole")] = gldconsole; 
lua[("save")] = saves; 
lua[("browser")] = browser;
lua["input"] = input;
lua["VK"] = vk;
lua["base64"] = base64;
/* (each different callabck is separate by new line on these comments)
* LUA CALLBACKS:
				for (auto current : lua.hooks.getHooks("on_launch")) -- when gld is launched. this is not recommended being used as it probably will be called before the script is fully loaded
		        current.func();

			    for (auto current : lua.hooks.getHooks("on_present")) -- main project loop
			    current.func();

 				for (auto current : lua.hooks.getHooks("on_gameselected")) -- when game is selected on search
				current.func();

				for (auto current : lua.hooks.getHooks("on_gamelaunch")) -- when game is launched
				current.func(g_Options.gamelaunched); -- refer to 	lua.new_usertype <GameInfo>(("GameInfo"), sol::constructors <>(),

				for (auto current : lua.hooks.getHooks("on_gamesearch")) -- when an game is searched
				current.func();

				for (auto current : lua.hooks.getHooks("on_extractioncompleted")) -- called when zip.extract is completed
				current.func(g_Options.isextractiondoneorigin, g_Options.isextractiondonepath); -- origin (file wich it got extracted from) and destination path (string)

				for (auto current : lua.hooks.getHooks("on_downloadclick")) -- when you click in download into game page
				current.func(g_Options.ondownloadclickcallbackitem.dump(), g_Options.ondownloadclickcallbackitemurl, g_Options.ondownloadclickcallbackscriptname); -- all are strings

				for (auto current : lua.hooks.getHooks("on_cfdone")) -- when http.CloudFlareSolver is finished
				current.func(g_Options.ongetcloudflarecookiec, g_Options.ongetcloudflarecookieurl); -- all string, first is the cookied then second is url

				for (auto current : lua.hooks.getHooks("on_downloadcompleted")) -- when an download is completed
				current.func(g_Options.ondownloadcompletedcallbackpath, g_Options.ondownloadcompletedcallbackurl); -- all strings

				for (auto current : lua.hooks.getHooks("on_setupcompleted")) -- when dll.innohook is completed
				current.func(g_Options.oninnopathextractioncallbackissfrom, g_Options.oninnopathextractioncallbackissto); -- all string, from the file getting extracted, to the destination where it extarcted

           		for (auto current : lua.hooks.getHooks("on_captchasolved")) -- when an captcha is solved on the lua browser
				current.func(browserID);

				for (auto current : lua.hooks.getHooks("on_captchadetected")) -- when a captcha is detected in the lua browser
				current.func(browserID);

				auto hooks = lua.hooks.getHooksFromScript(script, "on_scriptselected"); --  execute the function when a selecte is selected in the search (game) tab
				for (auto& current : hooks)
				{
					// Check if current.func is a valid function
					if (current.func)
					{
						safe_execute_function(current.func);
					}
					else
					{
						// Handle the error or skip this hook
						continue;
					}
				}

				for (auto current : lua.hooks.getHooks("on_quit")) -- when gld is exiting. not recommended being used on normal scripts. only if absolutelly needed
		        current.func();

				for (auto current : lua.hooks.getHooks("on_browserloaded")) -- when browser is done loading a page (its same as CefLoadHandler::OnLoadEnd from cef)
				current.func(browserID);

				for (auto current : lua.hooks.getHooks("on_browserconsolemessage")) -- when an browser console msg is output
			    current.func(browserID, g_Options.on_cef_console_msg_content); -- string with content of the msg

				for (auto current : lua.hooks.getHooks("on_beforedownload")) -- when an download is about to start (downalod solvers [resolvers] will be done here) [if returned download url is set as "cancel", the download will be cancelled]
				auto result = current.func(g_Options.onbeforedownloadcallbackurl); -- method of returning: returnurl: string, name: string, headers: vector<string> - Called before download starts; return modified values for download resolvers (return nil to keep original)[you will be solving/resolving downloads here]
				if (result.valid())
				{
					// Only update if the returned value is not nil
					if (result.get<sol::optional<std::string>>(0))
						g_Options.onbeforedownloadcallbackreturnurl = result.get<std::string>(0);

					if (result.get<sol::optional<std::string>>(1))
						g_Options.onbeforedownloadcallbackname = result.get<std::string>(1);

					if (result.get<sol::optional<std::vector<std::string>>>(2))
						g_Options.onbeforedownloadcallbackvector = result.get<std::vector<std::string>>(2);
				}

				for (auto current : lua.hooks.getHooks("on_browserbeforeresourceload")) -- when browser is about to load a resource (like an image,css,js,etc) (include even the page and requests like get post etc)
				current.func(browserID, g_Options.onbrowserBeforeResourceLoadUrl, g_Options.onbrowserBeforeResourceLoadMethod, g_Options.onbrowserBeforeResourceLoadReferrer, g_Options.onbrowserBeforeResourceLoadResourceType); -- all strings

				for (auto current : lua.hooks.getHooks("on_browserbeforedownload")) -- when browser is about to download a file (like when you click an download link in browser)
				auto result = current.func(browserID, g_Options.onbrowserBeforeDownloadUrl, g_Options.onbrowserBeforeDownloadSuggestedName, g_Options.onbrowserBeforeDownloadSize); -- all strings
				if (result.valid())
				{
					if (result.get<sol::optional<std::string>>(0))
						g_Options.onbrowserBeforeDownloadogUrl = result.get<std::string>(0); -- its needed for resolvers to reutnr here the original url of input
				}
*/
